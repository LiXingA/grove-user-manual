{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Treemap\n\nIntroduced by [Ben Shneiderman](http://www.cs.umd.edu/hcil/treemap-history/), treemaps recursively partition space into rectangles according to each nodeâ€™s associated value. D3 supports several treemap tiling methods. See also [nested](/@d3/nested-treemap), [zoomable](/@d3/zoomable-treemap) and [animated](/@d3/animated-treemap) treemaps.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"d3 = require(\"d3@6\")","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"format = d3.format(\",d\")","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"viewof tile = {\n  const options = [\n    {name: \"d3.treemapBinary\", value: d3.treemapBinary},\n    {name: \"d3.treemapDice\", value: d3.treemapDice},\n    {name: \"d3.treemapSlice\", value: d3.treemapSlice},\n    {name: \"d3.treemapSliceDice\", value: d3.treemapSliceDice},\n    {name: \"d3.treemapSquarify\", value: d3.treemapSquarify, selected: true}\n  ];\n  const form = html`<form style=\"display: flex; align-items: center; min-height: 33px;\"><select name=i>${options.map(o => Object.assign(html`<option>`, {textContent: o.name, selected: o.selected}))}`;\n  form.i.onchange = () => form.dispatchEvent(new CustomEvent(\"input\"));\n  form.oninput = () => form.value = options[form.i.selectedIndex].value;\n  form.oninput();\n  return form;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"treemap = data => d3.treemap()\n    .tile(tile)\n    .size([width, height])\n    .padding(1)\n    .round(true)\n  (d3.hierarchy(data)\n      .sum(d => d.value)\n      .sort((a, b) => b.value - a.value))","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"data = FileAttachment(\"#d3/flare-2.json\").json()","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"width = 954","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"height = 954","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"color = d3.scaleOrdinal(d3.schemeCategory10)","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"chart = {\n  const root = treemap(data);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"font\", \"10px\").style(\"color\",\"red\");\n\n  const leaf = svg.selectAll(\"g\")\n    .data(root.leaves())\n    .join(\"g\")\n      .attr(\"transform\", d => `translate(${d.x0},${d.y0})`);\n\n  leaf.append(\"title\")\n      .text(d => `${d.ancestors().reverse().map(d => d.data.name).join(\"/\")}\\n${format(d.value)}`);\n\n  leaf.append(\"rect\")\n      .attr(\"id\", d => (d.leafUid = DOM.uid(\"leaf\")).id)\n      .attr(\"fill\", d => { while (d.depth > 1) d = d.parent; return color(d.data.name); })\n      .attr(\"fill-opacity\", 0.6)\n      .attr(\"width\", d => d.x1 - d.x0)\n      .attr(\"height\", d => d.y1 - d.y0);\n\n  leaf.append(\"clipPath\")\n      .attr(\"id\", d => (d.clipUid = DOM.uid(\"clip\")).id)\n    .append(\"use\")\n      .attr(\"xlink:href\", d => d.leafUid.href);\n\n  leaf.append(\"text\")\n      .attr(\"clip-path\", d => d.clipUid)\n    .selectAll(\"tspan\")\n    .data(d => d.data.name.split(/(?=[A-Z][a-z])|\\s+/g).concat(format(d.value)))\n    .join(\"tspan\")\n      .attr(\"x\", 3)\n      .attr(\"y\", (d, i, nodes) => `${(i === nodes.length - 1) * 0.3 + 1.1 + i * 0.9}em`)\n      .attr(\"fill-opacity\", (d, i, nodes) => i === nodes.length - 1 ? 0.7 : null)\n      .text(d => d);\n\n  return svg.node();\n}","pinCode":true}}}],"version":"2.19.1"}