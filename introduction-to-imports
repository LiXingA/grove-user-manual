{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Introduction to Imports\n\nGrove lets you quickly reuse code by importing named cells from other notebooks.\n\nTo demonstrate, take my notebook of color scales used to visualize quantitative data. This notebook defines a *ramp* function that returns a canvas for a given *color* function, where the *color* function returns a color for a given ${tex`t \\in [0,1]`} from left to right. To create the dreaded angry rainbow, import and call *ramp*:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"import {chart as treemap}\nwith {treemap_data as data}\nfrom \"@d3/treemap\"","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"import {ramp} from \"@mbostock/color-ramp\"","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"ramp(t => `hsl(${t * 360}, 100%, 50%)`)","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"md`You could instead copy-paste the *ramp* function from that notebook into this one—it’s only a few lines of code. But imports have a few advantages.\n\nFirst, the cell you want to reuse may depend on other cells. If you copy-paste, you have to copy-paste those other cells too, and make sure that they don’t conflict with existing cells in your notebook. If you import, the dependencies are loaded automatically, so you don’t have to think about it.\n\nFor example, consider a notebook on an interrupted Sinu–Mollweide map projection that requires the D3 and TopoJSON libraries, along with geometry representing the Earth’s landmasses. You can import the map and display it without worrying about how the sausage is made.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"import {map} from \"@d3/interrupted-sinu-mollweide\"","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"map","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"md`Second, by importing, it’s easier to keep the reused code up-to-date. Imports target the latest published version, so if I improve my map notebook, the new map will automatically appear here.\n\n(The risk of importing the latest version is that your notebook may break if the imported notebook changes in a non-backwards-compatible way. Observable also supports versioned imports, however version numbers aren’t currently exposed in the user interface, so for now you must specify the version manually. In the future, imports will be pinned to the latest published version at the time you write the import statement, and can be re-pinned on-demand.)`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Third, and most excitingly, Observable imports let you inject dependencies using import-with! This lets you “rewrite” imported code as you might do when copy-pasting, without the problems of code duplication.\n\nConsider my D3 treemap notebook that visualizes the Flare dataset. To reuse this treemap implementation to visualize a different dataset, inject a new definition of *data* in the with clause on import:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"treemap","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"treemap_data = await FileAttachment(\"#d3.json\").json()","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"md`As long as the new data conforms to the same shape as the old data (here, a tree of objects with *children* and *value* properties), you can reuse the existing code without copy-paste and the terrible challenge of designing a reusable chart abstraction!\n\nBest of all, because [Observable is reactive](/@observablehq/how-observable-runs), you can even inject dynamic definitions into code that was previously static!\n\nFor example, below is a histogram of a synthetic beta distribution using ${tex`\\alpha`} and ${tex`\\beta`} values that are controlled by sliders. Whenever ${tex`\\alpha`} or ${tex`\\beta`} change, Observable automatically updates the histogram—even though the implementation is reused from a static histogram of unemployment rates.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"// Returns a normal deviate (mu=0, sigma=1).\nfunction randn() {\n  let u, v, x, y, q;\n  do {\n    u = Math.random();\n    v = 1.7156 * (Math.random() - 0.5);\n    x = u - 0.449871;\n    y = Math.abs(v) + 0.386595;\n    q = x * x + y * (0.19600 * y - 0.25472 * x);\n  } while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math.log(u) * u * u));\n  return v / u;\n}","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"// Returns a gamma deviate by the method of Marsaglia and Tsang.\nfunction randg(shape) {\n  let oalph = shape, a1, a2, u, v, x, mat;\n  if (!shape) shape = 1;\n  if (shape < 1) shape += 1;\n  a1 = shape - 1 / 3;\n  a2 = 1 / Math.sqrt(9 * a1);\n  do {\n    do {\n      x = randn();\n      v = 1 + a2 * x;\n    } while (v <= 0);\n    v = v * v * v;\n    u = Math.random();\n  } while (\n    u > 1 - 0.331 * Math.pow(x, 4) &&\n    Math.log(u) > 0.5 * x * x + a1 * (1 - v + Math.log(v))\n  );\n  if (shape === oalph) return a1 * v; // alpha > 1\n  do u = Math.random(); while (u === 0); // alpha < 1\n  return Math.pow(u, 1 / oalph) * a1 * v;\n}","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"function randb(alpha, beta) {\n  const u = randg(alpha);\n  return u / (u + randg(beta));\n}","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"histogram_data = new Array(10000).fill().map(() => randb(...alphabeta))","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"import {chart as histogram}\nwith {histogram_data as data}\nfrom \"@d3/histogram\"","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"viewof alphabeta = {\n  const form = html`<form style=\"font: 12px var(--sans-serif);\">\n  <label style=\"display: block;\">\n    <input name=a type=range min=0 max=5 step=0.01 style=\"width:180px;\">\n    ${tex`\\alpha`} = <output name=oa></output>\n  </label>\n  <label style=\"display: block;\">\n    <input name=b type=range min=0 max=5 step=0.01 style=\"width:180px;\">\n    ${tex`\\beta`} = <output name=ob></output>\n  </label>\n</form>`;\n  form.oninput = () => {\n    form.value = [form.a.valueAsNumber, form.b.valueAsNumber];\n    form.oa.value = form.a.valueAsNumber;\n    form.ob.value = form.b.valueAsNumber;\n  };\n  form.oninput();\n  return form;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"histogram","pinCode":true}}},{"type":"codeTool","data":{"codeData":{"value":"md`Here are a few additional nuances of imports:\n\nLike [ES imports](http://exploringjs.com/es6/ch_modules.html), Observable imports are live bindings. If you import a value that changes over time ([a generator cell](/@mbostock/generator-cells-functions-and-objects)), such as a countdown to a certain date in the future, the imported value will change over time, too.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"import {interval} from \"@mbostock/countdown\"","pinCode":true}}}],"version":"2.19.1"}